---
layout: post
title: Clojure Programming Environment Setup
tags: [clojure, emacs]
author_name: Joe O'Pecko
author_uri: http://twitter.com/opeckojo
---

Lately I've been splitting my time between learning "Clojure":http://clojure.org and "Scala":http://www.scala-lang.org. In the process I'm attempting to cover both ends of the static/dynamic spectrum and avoid spending all of my time in one camp.

As part of getting started learning Clojure, specifically, I think its imperitive to spend some time upfront and get a good development environment in place in order to facilitate the development activities. Fortunately, for anyone familiar with Emacs and Lisp, the environment should be very familiar even if the language looks a little foreign. Now that's not to say that the tools for doing Scala development are not important too. Using Emacs with the "yasnippet":http://code.google.com/p/yasnippet/ template system makes Scala development a joy as well. However, given the dynamic nature of Clojure and the incremental development process encouraged by the Lisp-way of doing things, I feel that getting the environment set up properly is crucial to take advantage of the productivity gains it affords the developer.

Additionally, since I split my time on different machines with different Operating Systems, both at home and work, its important that my environment travel well. For me this means that first and foremost its accessible from anywhere. For now, this means that its in a repository up on "GitHub":http://github.com.

By no means am I an Emacs/Elisp power user and having spent some considerable time with Emacs, mostly while learning how to use it, I found that my .emacs atrophied over time. Therefore, I opted to stand on the shoulders of giants and fork Jim Weirich's excellent Emacs setup to use as the basis of my Emacs 2.0 environment. It really does help when you have the opportunity to learn from people who are more versed with the tools, especially one as rich and robust as Emacs, where the number of knobs to tune and extensions to wade through are mindboggling.

For those interested in the details, my GitHub repo can be found "here":http://github.com/opeckojo/emacs-setup/tree/master. From this point on, I'm going to leave out how my .el files are wired up and focus just on getting Clojure integration setup.

To get started with Clojure you'll at least need a Java runtime. Download and install Java version 5 or greater. Java version 6 has signiﬁcant performance improvements and better exception reporting, so prefer this if possible. If you're going to be installing Clojure from source you'll also need Git and Ant as well.

The first thing to do is to get the tools downloaded and installed. Here is a simple script that can get you going. It removes everything and re-installs when its called. This was written before Clojure went 1.0 and I wanted to stay on the cutting edge. Please be cautious and amend this as per your requirements before running.

{% highlight bash %}
#!/bin/sh

if [ $# -ne 1 ]; then
    echo "Please specify the clojure root directory" >2
fi

CLJ_ROOT="$1"

cd $CLJ_ROOT
rm -dfr clojure
rm -dfr clojure-contrib
rm -dfr clojure-mode
rm -dfr swank-clojure

# download the Clojure resources
git clone git://github.com/jochu/clojure-mode.git
git clone git://github.com/jochu/swank-clojure.git
git clone git://github.com/richhickey/clojure.git
git clone git://github.com/richhickey/clojure-contrib.git

# compile Clojure
cd clojure
ant

# compile the clojure-contrib library
cd ../clojure-contrib
ant
{% endhighlight %}

Now that the Clojure tools are in place, we need to get our hands on SLIME. You'll need to decide on a location for this on your disk as well. For my MacBook, the last one I installed this on, I selected the location /opt/slime. Once you've decided on a location, you'll need to invoke the following:

{% highlight bash %}
cd /opt/
cvs -d :pserver:anonymous:anonymous@common-lisp.net:/project/slime/cvsroot co slime
{% endhighlight %}

As invoked this will place all of the code for the SLIME mode under the /opt/slime directory.

Now that the extensions and libraries have been downloaded, its time to set up Emacs. For me, since I still want to be able to use the same .emacs configuration on different machines, I need to have a place where I can specify machine-specific configuration such as the location on disk of any tools I installed. I have a special file reserved for just such occassion. If it exists, the file ~/.emacs.d/local.el is loaded before any of my load files so that I can first specify the information that other elisp files depend upon. In this case, the clojure.el file, which sets up the modes for Clojure development and the slime.el file, which sets up SLIME mode, are loaded _after_ local.el.

For this example, my local.el would contain the following:

{% highlight clojure %}
(setq clojure-root "/opt/clojure")
(setq slime-dir "/opt/slime")
{% endhighlight %}

To get clojure-mode and swank-clojure going, the following worked for me:

{% highlight clojure %}
;;; ==================================================================
;;; Author:  Joe O'Pecko
;;; File:    clojure.el
;;; Purpose: Setup for Clojure mode
;;; ==================================================================

;;____________________________________________________________________
;;;;    Programming - Clojure

(setq clojure-mode-dir (concat clojure-root "/clojure-mode"))
(when (file-directory-p clojure-mode-dir)
  (add-to-list 'load-path clojure-mode-dir)
  (autoload 'clojure-mode "clojure-mode" "A major mode for Clojure" t)
  (add-to-list 'auto-mode-alist '("\\.clj$" . clojure-mode)))

;; swank-clojure
(setq swank-clojure-dir (concat clojure-root "/swank-clojure"))
(when (file-directory-p swank-clojure-dir)
  (add-to-list 'load-path swank-clojure-dir)
  (setq swank-clojure-binary (concat home-dir "bin/clj"))
  (require 'swank-clojure-autoload))

{% endhighlight %}

At this point, you may be wondering what that reference to "bin/clj" is in the swank-clojure setup. In addition to my Emacs setup, I also have a move-in repository which contains my dotfiles and some scripts that I've found useful over time. When using swank, it requires that you specify a binary to start up....

Below is the contents of my clj shell script. I've used the script found here.

{% highlight bash %}
#!/bin/sh
#
# A launcher script for Clojure programs. These environment variables can be
# used to configure the script:
#
#   CLOJURE_HOME
#       The root directory where Clojure is installed.
#   CLOJURE_JAVA
#       The name of the java executable used to run Clojure.
#   CLOJURE_JAVA_OPTS
#       Additional options to be passed to the java executable.
#   CLOJURE_CLASSPATH
#       A path to be added to Clojure's classpath.
#   CLOJURE_LIBRARY_PATH
#       A path to be searched for native code such as DLL's or JNI
#       libraries. This gets added to the Java options as
#       "-Djava.library.path=$CLOJURE_LIBRARY_PATH".
#   CLOJURE_LIB
#       This directory, and any jars inside it, will be automatically
#       added to Clojure's classpath.
#
#   CLOJURE_JLINE
#        This should be the path to Jline jar.
# TODO:
#   make CLOJURE_LIB a path instead of a single directory
#   allow for adding to CLOJURE_LIB from the command line

usage="\
usage: clojure [options] [file1 [file2] ...]

Options:
  --help, -h          show this message
  --java-cmd, -J      the Java executable to use
  --java-opts, -j     add options to be passed on to the JVM
  --classpath, -cp    add to Clojure's classpath
  --library-path, -L  add to the path to search for native libraries
  --interactive, -i   run the interactive Clojure repl
"
## read ~/.clojurerc for home configuration
[ -e ~/.clojurerc ] && . ~/.clojurerc

## read ./.clojurerc for project specific configuration
[ -e ./.clojurerc ] && . ./.clojurerc

if [ ! "$CLOJURE_HOME" ]; then
    # Find the real path to Clojure's home directory if $0 is a symlink
    program="$0"
    while [ -h "$program" ]; do
        ls=`ls -ld "$program"`
        link=`expr "$ls" : '.*-> \(.*\)$'`
        if expr "$link" : '.*/.*' >/dev/null; then
            program="$link"
        else
            program="`dirname $program`/$link"
        fi
    done
    script_dir=`dirname "$program"`
    relative_clojure_home=`dirname "$script_dir"`
    CLOJURE_HOME=`cd "$relative_clojure_home" && pwd`
fi

if [ ! "$CLOJURE_JAVA" ]; then
    CLOJURE_JAVA="java";
fi

if [ ! "$CLOJURE_JAVA_OPTS" ]; then
    CLOJURE_JAVA_OPTS="-Dpid=$$"; # set the pid for SLIME
fi

if [ ! "$CLOJURE_CLASSPATH" ]; then
    CLOJURE_CLASSPATH="."
fi

##  Add Clojure home jars.
for jar in "$CLOJURE_HOME"/*.jar; do
    CLOJURE_CLASSPATH="$CLOJURE_CLASSPATH:$jar"
done

if [ -d "$CLOJURE_LIB" ]; then
    CLOJURE_CLASSPATH="$CLOJURE_CLASSPATH:$CLOJURE_LIB"
    for jar in "$CLOJURE_LIB"/*.jar; do
        CLOJURE_CLASSPATH="$CLOJURE_CLASSPATH:$jar"
    done
fi
echo $CLOJURE_CLASSPATH

main="clojure.lang.Script"

for arg in "$@"; do
    case $arg in
        -h|--help)
            echo "$usage"; exit 1;;
        -J|--java-cmd)
            CLOJURE_JAVA="$2"; shift; shift;;
        -j|--java-opts)
            CLOJURE_JAVA_OPTS="$CLOJURE_JAVA_OPTS $2"; shift; shift;;
        -cp|--classpath)
            CLOJURE_CLASSPATH="$CLOJURE_CLASSPATH:$2"; shift; shift;;
        -L|--library-path)
            if [ "$CLOJURE_LIBRARY_PATH" ]; then
                CLOJURE_LIBRARY_PATH="$CLOJURE_LIBRARY_PATH:$2";
            else
                CLOJURE_LIBRARY_PATH="$2";
            fi
            shift; shift;;
        -i|--interactive)
            main="clojure.lang.Repl"; repl=1; shift;;
        *) break;;
    esac
done

# If we didn't get any files to load on the commandline, we want to run the
# repl regardless of the -i switch
if [ $# -eq 0 ]; then
    main="clojure.lang.Repl"
    repl=1
fi

# If the classpath contains the JLine jar, use the JLine console runner
if expr "$CLOJURE_CLASSPATH" : ".*jline.*\.jar" >/dev/null; then 
    [ $repl -eq 1 ] && jline="jline.ConsoleRunner"
fi

# Enable rlwrap if present
if [ $repl -eq 1 ] && [ -z $jline ]; then
    rlwrap=`type -p rlwrap`
fi

## Add CLOJURE_LIBRARY_PATH to the Java options if necessary
if [ -n "$CLOJURE_LIBRARY_PATH" ]; then
    CLOJURE_JAVA_OPTS="$CLOJURE_JAVA_OPTS -Djava.library.path=$CLOJURE_LIBRARY_PATH"
fi

## Load ~/.clojure.clj on startup if it exists
init=`[ -e $HOME/.clojure.clj ] && echo $HOME/.clojure.clj`
cmd=`echo $rlwrap "$CLOJURE_JAVA" "$CLOJURE_JAVA_OPTS" -cp "$CLOJURE_CLASSPATH" $jline $main $init "$@"`
echo "$cmd"
exec `echo $cmd`
{% endhighlight %}

Lastly, in order for this script to launch properly, we need to have a machine-specific ~/.clojurerc. For the install we just described, here's a suitable one:

{% highlight bash %}
CLOJURE_HOME=/opt/clojure/clojure

# Directory where libaries/jar files can be found
CLOJURE_CLASSPATH=~/.clojure

###
# Various java options:
###

# set the pid for SLIME
CLOJURE_JAVA_OPTS="-Dpid=$$"

# Memory settings
# CLOJURE_JAVA_OPTS="$CLOJURE_JAVA_OPTS -Xms500m -Xmx1g"
# CLOJURE_JAVA_OPTS="$CLOJURE_JAVA_OPTS -XX:+UseConcMarkSweepGC"
# CLOJURE_JAVA_OPTS="$CLOJURE_JAVA_OPTS -XX:+HeapDumpOnOutOfMemoryError"

# Debug settings
CLOJURE_JAVA_OPTS="$CLOJURE_JAVA_OPTS -server"
CLOJURE_JAVA_OPTS="$CLOJURE_JAVA_OPTS -Xdebug"
CLOJURE_JAVA_OPTS="$CLOJURE_JAVA_OPTS -Xrunjdwp:transport=dt_socket,server=y,suspend=n"
{% endhighlight %}

You can test whether or not this script works by invoking it from the command line...

Put instructions on setting up rlwrap here...since it makes auto completion possible
