---
layout: post
title: Learning Ruby with Project Euler
tags: [ruby, euler]
author_name: Joe O'Pecko
author_uri: http://twitter.com/opeckojo
---

Like others I'm currently using "Project Euler":http://projecteuler.net/ to help me learn Ruby and escape some of the doldrums of Java development. One of my concerns, and maybe this is a little premature, is that since I try to strive for idiomatic code in the language I am using, I'm not sure I'm actually hitting the mark with my solutions.

"Add all the natural numbers below one thousand that are multiples of 3 or 5.":http://projecteuler.net/index.php?section=problems&id=1

{% highlight ruby %}
(1...1000)
  .select { |n| n % 3 == 0 || n % 5 == 0 }
  .inject(0) { |result, element| result + element }
{% endhighlight %}

"Find the sum of all the even-valued terms in the Fibonacci sequence which do not exceed four million.":http://projecteuler.net/index.php?section=problems&id=2

{% highlight ruby %}
def fib
  x, y = 0, 1
  loop do
    yield y
    x,y = y, x+y
  end
end

x = 0
fib do |n|
  break if n > 4000000
  x += n if n % 2 == 0
end

puts x
{% endhighlight %}

I'm fairly certain that the solution to the first problem is as concise as it should be without sacrificing readability. However, the second one may stand for some refactoring. I'm not sure how I feel about it. It solves the problem but it still feels like it could be better. Although I can't quite verbalize what better means. Maybe its due to my choice in using an infinite fibonacci sequence that makes me feel uneasy. This decision required me to issue a break statement from within the block I'm passing into the fib function to terminate the computation. I'm sure as I learn more Ruby this will become more evident to me but for now I'll deal with having a working, albeit perhaps less than ideal, solution.

Going forward, I may put this Project Euler activity on hold until I get a little more comfortable with Ruby as I'm not convinced that its the right thing to try to learn a language with. I'll probably try my hand at learning Ruby via [BT]DD with the "KataCatalogue":http://codingdojo.org/cgi-bin/wiki.pl?KataCatalogue. I recently watched a video on InfoQ with Aslak Hellesoy entitled "Executable User Stories with RSpec and BDD":http://www.infoq.com/presentations/hellesoy-bdd-rspec which captured my interest. In the talk he mentioned the Bowling Kata as a good learning exercise. This will hopefully give me an opportunity to cut my teeth on "Cucumber":http://cukes.info/ and "RSpec":http://rspec.info/ too.

**Updated 2009 May 3:**
I recently received the updated PickAxe book and have stumbled across another way to implement the second Project Euler problem that seems a little cleaner than my first attempt and would like to share it here. In chapter 4 on page 63, there's a subsection describing infinite sequences which I thought would map cleanly to this particular problem. The code is mostly lifted from the book and modified for my domain where necessary. Here's what I hacked up:

{% highlight ruby %}
def infinite_select(enum, &block)
  Enumerator.new do |yielder|
    enum.each do |value|
      yielder.yield(value) if block.call(value)
    end
  end
end

fib_numbers = Enumerator.new do |yielder|
  x, y = 0, 1
  loop do
    yielder.yield y
    x, y = y, x + y
  end
end

p infinite_select(fib_numbers) {|val| val % 2 == 0}
    .take_while {|x| x < 4000000}
    .inject{|sum, i| sum+i}
{% endhighlight %}

I like this since it doesn't break encapsulation by having a break passed into the block like in the previous solution. This is dependent on Ruby 1.9, which introduced Enumerators, however, I think its a little cleaner.

Or, if I monkey-patch the Enumerator class:

{% highlight ruby %}
fib_numbers = Enumerator.new do |yielder|
  # ... as before
end

class Enumerator
  def infinite_select(&block)
    Enumerator.new do |yielder|
      self.each do |value|
        yielder.yield(value) if block.call(value)
      end
    end
  end
end

p fib_numbers
    .infinite_select {|val| val % 2 == 0}
    .take_while {|x| x < 4000000}
    .inject {|sum,i| sum+i}
{% endhighlight %}

I think that either way is still cleaner than my original attempt. Can't stop the learning!

