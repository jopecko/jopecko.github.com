---
layout: post
title: Groovier internationalization
tags: [groovy, i18n]
author_name: Joe O'Pecko
author_uri: http://twitter.com/opeckojo
---

While working on the shrink wrapped product for the day job, I was recently tasked with rewriting the mechanisms used for internalization (i18n). As per company policy, towards the end of the development cycle, the English resource bundle(s) are sent off to a centralized globalization team from which the returned translations are returned and subsequently integrated into the product.

blah blah resource bundles

From within the code that actually utilizes the internationalized text, I'm partial to placing the resource bundles along side the actual code. Translated into Java parlance, this means that the message files live in the package structure alongside the class's that they are used in. When it comes time to package code in JARs/WARs/etc., this makes for easy bundling and during coding, usage is fairly straightforward as well since the bundle name can be easily inferred from the package structure. This seems cleaner overall and compartmentalized to me and I also wanted to follow a similar scheme since I feel it makes packaging and code cleaner. Since these messages are subject to change each release it is easy to see that it could quickly become unweidly to manage the overwhelming number of files if this scheme were followed.

Not to be discouraged, I devised a simple solution to accomodate this. During development, all my team needs to maintain is a single file that contains all of the externalized messages for the application. This way the developers only need to worry about maintaining a single file, and the translation team only need to return a single file for each supported language. In order to have a simple API for dealing with these messages... Then through the magic of some groovy flavored ant scripting, for legacy reasons ant is still the build tool of choice, the build script can perform some preprocesing of these property files before packaging commenses.

Mixing groovy inside of an ant script can spell disaster, but in the absense of a real build scripting tool, XML is not a suitable scripting language, I feel that this is an acceptable compromise. Additionally, with the terseness of groovy, or most any dynamic language these days, the amount of code sprinkled in the ant script is small.

Without further ado, here is the code I came up with, nothing overly complicated or clever, but it gets the job done. Included below is the code that is inlined in the build script within the groovy ant task.

{% highlight groovy %}
def propsPattern = /.*messages.*properties$/
def propsFileDir = new File("${properties['application.props.dir']}")
propsFileDir.listFiles().grep(~propsFilePattern).each { candidate ->
    def map = [:]
    candidate.eachLine { line ->
        line = line.trim()
        if (!line.startsWith("#")
            if (line.length() > 0) {
                String[] sa = line.split(":")
                if (sa.length != 2)
                    throw new IllegalArgumentException("invalid line " + line)
                def list = map.get(sa[0], [])
                list.add(sa[1])
            }
        }
    }


    // for each key, write out file per package within specified package
    map.each { k,v ->
        def parent = new File(k.replaceAll("\\.", "/"))
        parent.mkdirs()
        new File(parent, candidate.name).withWriter { file ->
            // write out copyright
            v.each { file.writeLine("${it}") }
        }
        println "Wrote ${candidate.name} file for package ${k}"
    }
}
{% endhighlight %}

The only downside to embedding Groovy code inside an ant script, besides the obvious paradigm shift needed to grok it, is that certain characters are disallowed inside the code. For instance, its not possible to use the binary and "&&" operator inside the embedded script.
